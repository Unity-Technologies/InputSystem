#if UNITY_EDITOR
using System;
using System.Linq;
using System.Collections.Generic;
using NUnit.Framework;
using Mono.Cecil;

partial class APIVerificationTests
{
    private bool IsValidNameForConstant(string name)
    {
        return char.IsUpper(name[0]);
    }

    private bool TypeHasValidNamespace(TypeReference type)
    {
        // The compiler generates a <Module> type which we want to ignore
        return type.Namespace.StartsWith("UnityEngine.InputSystem") || type.Name == "<Module>";
    }

    private bool IsTypeWhichCanHavePublicFields(TypeReference type)
    {
        if (type == null)
            return false;

        // MonoBehaviour uses public fields for serialization
        if (type.FullName == "UnityEngine.MonoBehaviour" ||
            // MonoBehaviour-derived, but listed explicitly, as Cecil may not have the path to resolve the UI assembly.
            type.FullName == "UnityEngine.EventSystems.BaseInputModule" || 
            type.FullName == "UnityEngine.EventSystems.EventSystem" ||
            // These have fields popuplated by reflection in the Input System
            type.FullName == "UnityEngine.InputSystem.InputProcessor" ||
            type.FullName == "UnityEngine.InputSystem.InputControl" ||
            type.FullName == "UnityEngine.InputSystem.InputBindingComposite")
            return true;
        var res = type.Resolve();
        if (res != null)
        {
            if (res.IsValueType ||
                res.Interfaces.Any(i => i.InterfaceType.FullName == "UnityEngine.InputSystem.IInputInteraction") ||
                IsTypeWhichCanHavePublicFields(res.BaseType))
                return true;
        }
        return false;
    }

    private IEnumerable<TypeDefinition> GetInputSystemPublicTypes()
    {
        var codeBase = typeof(UnityEngine.InputSystem.InputSystem).Assembly.CodeBase;
        var uri = new UriBuilder(codeBase);
        var path = Uri.UnescapeDataString(uri.Path);
        var asmDef = AssemblyDefinition.ReadAssembly(path);
        return asmDef.MainModule.Types.Where(type => type.IsPublic);
    }

    private IEnumerable<FieldDefinition> GetInputSystemPublicFields() => GetInputSystemPublicTypes().SelectMany(t => t.Resolve().Fields).Where(f => f.IsPublic);
    private IEnumerable<MethodDefinition> GetInputSystemPublicMethods() => GetInputSystemPublicTypes().SelectMany(t => t.Resolve().Methods).Where(m => m.IsPublic);

    [Test]
    [Category("API")]
    public void API_ConstantsAreAppropriatelyNamed()
    {
        var incorrectlyNamedConstants = GetInputSystemPublicFields().Where(field => field.HasConstant && !IsValidNameForConstant(field.Name));
        Assert.That(incorrectlyNamedConstants, Is.Empty);
    }

    [Test]
    [Category("API")]
    public void API_TypesHaveAnAppropriateNamespace()
    {
        var incorrectlyNamespacedTypes = GetInputSystemPublicTypes().Where(t => !TypeHasValidNamespace(t));
        Assert.That(incorrectlyNamespacedTypes, Is.Empty);
    }

    [Test]
    [Category("API")]
    public void API_FieldsAreNotIntPtr()
    {
        var intptrFields = GetInputSystemPublicFields().Where(f => f.FieldType.Name == "IntPtr");
        Assert.That(intptrFields, Is.Empty);
    }

    [Test]
    [Category("API")]
    public void API_MethodReturnTypesAreNotIntPtr()
    {
        var intptrMethods = GetInputSystemPublicMethods().Where(m => m.ReturnType.FullName == "System.IntPtr");
        Assert.That(intptrMethods, Is.Empty);
    }

    [Test]
    [Category("API")]
    public void API_MethodParameterTypesAreNotIntPtr()
    {
        // Ignore IntPtr parameters on delegate constructors. These are generated by the compiler and not within our control
        var intptrMethods = GetInputSystemPublicMethods().Where(m => m.DeclaringType.BaseType?.FullName != "System.MulticastDelegate" && m.Parameters.Any(p => p.ParameterType.FullName == "System.IntPtr"));
        Assert.That(intptrMethods, Is.Empty);
    }

    [Test]
    [Category("API")]
    public void API_NoDisallowedPublicFields()
    {
        var disallowedPublicFields = GetInputSystemPublicFields().Where(field => !field.HasConstant && !IsTypeWhichCanHavePublicFields(field.DeclaringType));
        Assert.That(disallowedPublicFields, Is.Empty);
    }
}
#endif
